#compilador.py
import os
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox, Menu
import re

# Importamos las clases para el analizador l√©xico
from lexico import TokenType, Token, LexicalAnalyzer

from sintactico import Parser
from arbol_sintaxis import ASTNode



class CompiladorIDE:
    def __init__(self, root):
        self.root = root
        self.root.title("Compilador IDE")
        self.nombreArchivo = None
        
        # Inicializar el analizador l√©xico
        self.analizador_lexico = LexicalAnalyzer()
        
        # Definir colores para resaltado de sintaxis
        self.token_colors = {
            TokenType.NUMBER: "#007ACC",         # Azul
            TokenType.IDENTIFIER: "#000000",     # Negro
            TokenType.COMMENT: "#008000",        # Verde
            TokenType.RESERVED_WORD: "#800080",  # P√∫rpura
            TokenType.ARITHMETIC_OP: "#FF0000",  # Rojo
            TokenType.RELATIONAL_OP: "#FF8C00",  # Naranja
            TokenType.LOGICAL_OP: "#FF8C00",     # Naranja (Mismo que relacional)
            TokenType.SYMBOL: "#000000",         # Negro
            TokenType.ASSIGNMENT: "#FF0000",     # Rojo
            TokenType.ERROR: "#FF0000",          # Rojo
            TokenType.CHAR: "#93b121",           # Verde oscuro
            TokenType.STRING: "#93b121",         # Verde oscuro
            TokenType.INCREMENT: "#0080FF",    # Azul brillante
            TokenType.DECREMENT: "#FF8000",   # Naranja fuerte
            TokenType.INTEGER: "#007ACC",   # Azul para enteros
            TokenType.DECIMAL: "#009688"   # Otro color para decimales (o el mismo si prefieres)

        }
                # Aplicar estilo moderno a la interfaz
        self.estilo = ttk.Style()
        self.estilo.theme_use('clam')  # O usa 'alt', 'default', 'vista', seg√∫n lo que tengas instalado

        # Personalizar colores y widgets
        self.estilo.configure('.', font=('Segoe UI', 10))
        self.estilo.configure('TButton', padding=6, relief='flat', background='#4A90E2', foreground='white')
        self.estilo.map('TButton', background=[('active', '#357ABD')])
        self.estilo.configure('TNotebook.Tab', padding=[10, 5], font=('Segoe UI', 9, 'bold'))

        # Fondo m√°s claro para editor y pesta√±as
        self.estilo.configure('TFrame', background='#f0f0f0')
        self.estilo.configure('TNotebook', background='#e6e6e6')
        self.estilo.configure('TLabel', background='#f0f0f0')

        # Colores espec√≠ficos para estado
        self.estilo.configure('Status.TLabel', background='#e6e6e6', foreground='#333333', font=('Segoe UI', 9))

        self.configurar_interfaz()

    def configurar_interfaz(self):
        # Crear el men√∫ principal
        self.barraMenu = tk.Menu(self.root)
        self.root.config(menu=self.barraMenu)

        # Men√∫ Archivo
        menuArchivo = tk.Menu(self.barraMenu, tearoff=0)
        self.barraMenu.add_cascade(label="Archivo", menu=menuArchivo)
        menuArchivo.add_command(label="Nuevo", command=self.archivo_nuevo)
        menuArchivo.add_command(label="Abrir", command=self.archivo_abrir)
        menuArchivo.add_command(label="Guardar", command=self.archivo_guardar)
        menuArchivo.add_command(label="Guardar como", command=self.archivo_guardar_como)
        menuArchivo.add_separator()
        menuArchivo.add_command(label="Salir", command=self.root.quit)

        # Men√∫ Compilador
        menuCompilador = tk.Menu(self.barraMenu, tearoff=0)
        self.barraMenu.add_cascade(label="Compilador", menu=menuCompilador)
        menuCompilador.add_command(label="An√°lisis L√©xico", command=lambda: self.fase_compilacion("lexico"))
        menuCompilador.add_command(label="An√°lisis Sint√°ctico", command=lambda: self.fase_compilacion("sintactico"))
        menuCompilador.add_command(label="An√°lisis Sem√°ntico", command=lambda: self.fase_compilacion("semantico"))
        menuCompilador.add_command(label="C√≥digo Intermedio", command=lambda: self.fase_compilacion("intermedio"))
        menuCompilador.add_command(label="Ejecutar", command=self.ejecutar_codigo)

        # Men√∫ Ayuda
        menuAyuda = tk.Menu(self.barraMenu, tearoff=0)
        self.barraMenu.add_cascade(label="Ayuda", menu=menuAyuda)
        menuAyuda.add_command(label="Acerca de", command=self.mostrar_acerca_de)

        # Barra de estado en la parte inferior
        status_frame = ttk.Frame(self.root)
        status_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.status_position = ttk.Label(status_frame, text="L√≠nea: 1, Columna: 1", style='Status.TLabel')
        self.line_count_label = ttk.Label(status_frame, text="Total l√≠neas: 1", style='Status.TLabel')
        self.file_info = ttk.Label(status_frame, text="No guardado", style='Status.TLabel')

       
        self.status_position.pack(side=tk.LEFT, padx=5)

        ttk.Separator(status_frame, orient='vertical').pack(side=tk.LEFT, fill='y', padx=5)

        self.line_count_label = ttk.Label(status_frame, text="Total l√≠neas: 1")
        self.line_count_label.pack(side=tk.LEFT, padx=5)

        ttk.Separator(status_frame, orient='vertical').pack(side=tk.LEFT, fill='y', padx=5)

        self.file_info = ttk.Label(status_frame, text="No guardado")
        self.file_info.pack(side=tk.LEFT, padx=5)

        # Frame principal con tres paneles
        self.framePrincipal = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        self.framePrincipal.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        # Panel izquierdo (editor)
        self.frameIzquierdo = ttk.Frame(self.framePrincipal)
        self.framePrincipal.add(self.frameIzquierdo)

        # Panel derecho dividido (an√°lisis arriba, errores/salida abajo)
        self.frameDerecho = ttk.PanedWindow(self.framePrincipal, orient=tk.VERTICAL)
        self.framePrincipal.add(self.frameDerecho)

        # Panel para an√°lisis
        self.frameAnalisis = ttk.Frame(self.frameDerecho)
        self.frameDerecho.add(self.frameAnalisis)

        # Panel para errores y salida
        self.frameErroresSalida = ttk.Frame(self.frameDerecho)
        self.frameDerecho.add(self.frameErroresSalida)

        # Barra de herramientas
        barraHerramientas = ttk.Frame(self.frameIzquierdo)
        barraHerramientas.pack(fill=tk.X)

        # Crear botones sin iconos (podemos agregar iconos despu√©s)
        ttk.Button(barraHerramientas, text="Nuevo", command=self.archivo_nuevo).pack(side="left", padx=2)
        ttk.Button(barraHerramientas, text="Abrir", command=self.archivo_abrir).pack(side="left", padx=2)
        ttk.Button(barraHerramientas, text="Guardar", command=self.archivo_guardar).pack(side="left", padx=2)
        ttk.Button(barraHerramientas, text="Guardar como", command=self.archivo_guardar_como).pack(side="left", padx=2)
        ttk.Button(barraHerramientas, text="Compilar", command=lambda: self.fase_compilacion("all")).pack(side="left", padx=2)

        # Frame para el editor y n√∫meros de l√≠nea
        frameEditor = ttk.Frame(self.frameIzquierdo)
        frameEditor.pack(fill=tk.BOTH, expand=True)

        # Editor de texto con n√∫meros de l√≠nea
        self.numerosLinea = tk.Text(frameEditor, width=4, padx=3, takefocus=0, border=0,
                                  background='lightgray', state='disabled')
        self.numerosLinea.pack(side=tk.LEFT, fill=tk.Y)

        # Crear un frame contenedor para el editor y su scrollbar
        frameContenedorEditor = ttk.Frame(frameEditor)
        frameContenedorEditor.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Configurar el scrollbar del editor para sincronizar con los n√∫meros de l√≠nea
        scrollbar = ttk.Scrollbar(frameContenedorEditor)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Editor con scrollbar
        self.editor = scrolledtext.ScrolledText(frameContenedorEditor, wrap=tk.WORD, undo=True, yscrollcommand=scrollbar.set)
        self.editor.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        # Conectar el scrollbar con el editor y n√∫meros de l√≠nea
        scrollbar.config(command=self.on_scroll_both)
        
        # Configurar eventos para actualizar n√∫meros de l√≠nea y resaltado de sintaxis
        self.editor.bind('<Key>', self.on_key_press)
        self.editor.bind('<KeyRelease>', self.on_key_release)
        self.editor.bind('<Button-1>', self.update_status_bar)
        self.editor.bind('<MouseWheel>', self.sincronizar_scroll)  # Para Windows
        self.editor.bind('<Button-4>', self.sincronizar_scroll)  # Para Linux (scroll up)
        self.editor.bind('<Button-5>', self.sincronizar_scroll)  # Para Linux (scroll down)

        # Panel de an√°lisis (pesta√±as)
        self.pestanasAnalisis = ttk.Notebook(self.frameAnalisis)
        self.pestanasAnalisis.pack(fill=tk.BOTH, expand=True)

        # Pesta√±as para diferentes resultados de an√°lisis

        self.tabSintactico = ttk.Treeview(self.pestanasAnalisis, columns=("Tipo", "L√≠nea", "Columna"), show='tree headings')
        self.tabSintactico.heading("#0", text="Nodo")
        self.tabSintactico.heading("Tipo", text="Tipo")
        self.tabSintactico.heading("L√≠nea", text="L√≠nea")
        self.tabSintactico.heading("Columna", text="Columna")

        self.tabSintactico.column("#0", width=200)
        self.tabSintactico.column("Tipo", width=100, anchor="center")
        self.tabSintactico.column("L√≠nea", width=60, anchor="center")
        self.tabSintactico.column("Columna", width=80, anchor="center")



        scroll_sintactico = ttk.Scrollbar(self.pestanasAnalisis, orient="vertical", command=self.tabSintactico.yview)
        self.tabSintactico.configure(yscrollcommand=scroll_sintactico.set)
        self.tabSintactico.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scroll_sintactico.pack(side=tk.RIGHT, fill=tk.Y)

        self.tabLexico = scrolledtext.ScrolledText(self.pestanasAnalisis, wrap=tk.WORD)
        self.tabSemantico = scrolledtext.ScrolledText(self.pestanasAnalisis, wrap=tk.WORD)
        self.tabIntermedio = scrolledtext.ScrolledText(self.pestanasAnalisis, wrap=tk.WORD)
        self.tabTablaSimbolos = scrolledtext.ScrolledText(self.pestanasAnalisis, wrap=tk.WORD)

        self.pestanasAnalisis.add(self.tabLexico, text="An√°lisis L√©xico")
        self.pestanasAnalisis.add(self.tabSintactico, text="An√°lisis Sint√°ctico")
        self.pestanasAnalisis.add(self.tabSemantico, text="An√°lisis Sem√°ntico")
        self.pestanasAnalisis.add(self.tabIntermedio, text="C√≥digo Intermedio")
        self.pestanasAnalisis.add(self.tabTablaSimbolos, text="Tabla de S√≠mbolos")

        # Panel de errores y salida (pesta√±as)
        self.pestanasErroresSalida = ttk.Notebook(self.frameErroresSalida)
        self.pestanasErroresSalida.pack(fill=tk.BOTH, expand=True)

        # Pesta√±as para errores y salida
        self.tabErrores = scrolledtext.ScrolledText(self.pestanasErroresSalida, wrap=tk.WORD)
        self.tabSalida = scrolledtext.ScrolledText(self.pestanasErroresSalida, wrap=tk.WORD)

        self.pestanasErroresSalida.add(self.tabErrores, text="Errores")
        self.pestanasErroresSalida.add(self.tabSalida, text="Salida")

        # Configurar colores para errores
        self.tabErrores.tag_configure("error", foreground="black", spacing3=0)
        self.tabErrores.tag_configure("warning", foreground="orange")
        self.tabErrores.tag_configure("info", foreground="blue")

    def on_key_press(self, event=None):
        self.actualizar_numeros_linea()
        return True
    
    def on_key_release(self, event=None):
        self.update_status_bar()
        self.highlight_syntax()
        return True
    
    def imprimir_arbol_tabla(self, nodo, nivel=0, filas=None):
        if filas is None:
            filas = []

        if nodo:
            nombre = nodo.name if hasattr(nodo, 'name') else 'n/a'
            tipo = nodo.node_type if hasattr(nodo, 'node_type') else 'n/a'
            linea = str(nodo.line) if hasattr(nodo, 'line') else "-"
            columna = str(nodo.column) if hasattr(nodo, 'column') else "-"
            filas.append(f"{nombre:<20}{tipo:<20}{linea:<10}{columna:<10}")
            for hijo in nodo.children:
                self.imprimir_arbol_tabla(hijo, nivel + 1, filas)
        return filas


    def update_status_bar(self, event=None):
        # Actualizar informaci√≥n de posici√≥n del cursor
        cursor_position = self.editor.index(tk.INSERT)
        line, column = cursor_position.split('.')
        self.status_position.config(text=f"L√≠nea: {line}, Columna: {int(column) + 1}")
    
        # Actualizar contador de l√≠neas
        lines = self.editor.get('1.0', tk.END).count('\n')
        if lines < 1:
            lines = 1
        self.line_count_label.config(text=f"Total l√≠neas: {lines}")
    
        # Actualizar informaci√≥n del archivo
        if self.nombreArchivo:
            self.file_info.config(text=f"{os.path.basename(self.nombreArchivo)}")
        else:
            self.file_info.config(text="No guardado")
    
        # Tambi√©n actualizamos n√∫meros de l√≠nea
        self.actualizar_numeros_linea()
    
        return True

    def sincronizar_scroll(self, event=None):
        """Handle mouse wheel scrolling to synchronize editor and line numbers"""
        # For Windows and macOS
        if hasattr(event, 'delta'):
            if event.delta < 0:
                # Scroll down
                self.editor.yview_scroll(1, "units")
                self.numerosLinea.yview_scroll(1, "units")
            else:
                # Scroll up
                self.editor.yview_scroll(-1, "units")
                self.numerosLinea.yview_scroll(-1, "units")
        # For Linux
        else:
            if event.num == 4:
                # Scroll up
                self.editor.yview_scroll(-1, "units")
                self.numerosLinea.yview_scroll(-1, "units")
            elif event.num == 5:
                # Scroll down
                self.editor.yview_scroll(1, "units")
                self.numerosLinea.yview_scroll(1, "units")
        
        return "break"  # Prevent default behavior

    def actualizar_numeros_linea(self, event=None):
        # Obtener el n√∫mero total de l√≠neas
        contenido = self.editor.get('1.0', 'end-1c')
        lineas = contenido.count('\n') + 1
        
        # Generar texto con n√∫meros de l√≠nea
        texto_numeros = '\n'.join(str(i) for i in range(1, lineas + 1))
        
        # Actualizar el widget de n√∫meros de l√≠nea
        self.numerosLinea.config(state='normal')
        self.numerosLinea.delete('1.0', tk.END)
        self.numerosLinea.insert('1.0', texto_numeros)
        self.numerosLinea.config(state='disabled')
        
        # Sincronizar el scroll
        self.on_scroll('moveto', self.editor.yview()[0])
    
    def on_scroll(self, *args):
        # Sincronizar el scroll entre el editor y los n√∫meros de l√≠nea
        if args[0] == 'moveto':
            self.numerosLinea.yview_moveto(args[1])
        elif args[0] == 'scroll':
            self.numerosLinea.yview_scroll(int(args[1]), args[2])
    
    def on_scroll_both(self, *args):
        # Sincroniza tanto el editor como los n√∫meros de l√≠nea
        self.editor.yview(*args)
        self.numerosLinea.yview(*args)

    def archivo_nuevo(self):
        self.editor.delete('1.0', tk.END)
        self.nombreArchivo = None
        self.actualizar_numeros_linea()
        self.update_status_bar()

    def archivo_abrir(self):
        archivo = filedialog.askopenfilename(
            defaultextension=".txt",
            filetypes=[("Archivos de texto", "*.txt"), ("Todos los archivos", "*.*")]
        )
        if archivo:
            self.nombreArchivo = archivo
            self.editor.delete('1.0', tk.END)
            try:
                with open(archivo, 'r', encoding='utf-8') as f:
                    self.editor.insert('1.0', f.read())
            except UnicodeDecodeError:
                # Intentar con otra codificaci√≥n si utf-8 falla
                with open(archivo, 'r', encoding='latin-1') as f:
                    self.editor.insert('1.0', f.read())
            self.actualizar_numeros_linea()
            self.highlight_syntax()
            self.update_status_bar()
            self.root.title(f"Compilador IDE - {os.path.basename(archivo)}")

    def archivo_guardar(self):
        if not self.nombreArchivo:
            return self.archivo_guardar_como()

        try:
            content = self.editor.get('1.0', 'end-1c')
            with open(self.nombreArchivo, 'w', encoding='utf-8') as f:
                f.write(content)
            self.root.title(f"Compilador IDE - {os.path.basename(self.nombreArchivo)}")
            return True
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar el archivo: {str(e)}")
            return False 

    def archivo_guardar_como(self):
        archivo = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Archivos de texto", "*.txt"), ("Todos los archivos", "*.*")]
        )
        if archivo:
            self.nombreArchivo = archivo
            return self.archivo_guardar()
        return False
    


    def highlight_syntax(self):
        for tag in self.editor.tag_names():
            if tag != "sel":
                self.editor.tag_remove(tag, "1.0", tk.END)

        code = self.editor.get(1.0, tk.END)
        tokens, _ = self.analizador_lexico.analyze(code)

        for token in tokens:
            if not token.value.strip():
                continue

            try:
                start_line = token.line
                start_col = token.column - 1
                start_pos = f"{start_line}.{start_col}"

                lines = token.value.split('\n')
                if len(lines) == 1:
                    end_line = start_line
                    end_col = start_col + len(token.value)
                else:
                    end_line = start_line + len(lines) - 1
                    end_col = len(lines[-1])

                end_pos = f"{end_line}.{end_col}"

                tag_name = f"tag_{token.type.name}"
                if tag_name not in self.editor.tag_names():
                    self.editor.tag_configure(tag_name, foreground=self.token_colors[token.type])

                self.editor.tag_add(tag_name, start_pos, end_pos)

            except Exception:
                continue  # Ignora errores de tokens mal posicionados



                
    def fase_compilacion(self, fase):
        if not self.archivo_guardar():
            return

        # Limpiar pesta√±a de errores
        self.tabErrores.delete('1.0', tk.END)

        # Obtener el c√≥digo
        code = self.editor.get('1.0', 'end-1c')
        # === AN√ÅLISIS L√âXICO ===
        if fase == "lexico" or fase == "all":
            tokens, errors = self.analizador_lexico.analyze(code)

            self.tabLexico.delete('1.0', tk.END)
            self.tabLexico.insert('1.0', f"{'Tipo':<20}{'Valor':<20}{'L√≠nea':<10}{'Columna':<10}\n")
            self.tabLexico.insert(tk.END, "-" * 60 + "\n")

            for token in tokens:
                if token.type not in [TokenType.ERROR, TokenType.COMMENT]:
                    self.tabLexico.insert(
                        tk.END,
                        f"{token.type.name:<20}{token.value:<20}{token.line:<10}{token.column:<10}\n"
                    )

            # Mostrar errores solo si se est√° en an√°lisis l√©xico o 'all'
            if fase == "lexico" or fase == "all":
                self.tabErrores.delete('1.0', tk.END)  # Limpiar antes de mostrar errores nuevos
                if errors:
                    self.tabErrores.insert('1.0', "Errores detectados:\n\n", "error")
                    for i, error in enumerate(errors, 1):
                        self.tabErrores.insert(tk.END, f"{i}. {error}\n\n", "error")
                    self.pestanasErroresSalida.select(0)
                else:
                    self.tabErrores.insert('1.0', "No se encontraron errores en el an√°lisis l√©xico.\n", "info")

            # === Tabla de S√≠mbolos ===
            self.tabTablaSimbolos.delete('1.0', tk.END)
            self.tabTablaSimbolos.insert('1.0', "Tabla de S√≠mbolos:\n\n")
            self.tabTablaSimbolos.insert(tk.END, f"{'Identificador':<20}{'Tipo':<15}{'L√≠nea':<10}{'Columna':<10}\n")
            self.tabTablaSimbolos.insert(tk.END, "-" * 55 + "\n")

            unique_identifiers = {}
            for token in tokens:
                if token.type == TokenType.IDENTIFIER and token.value not in unique_identifiers:
                    unique_identifiers[token.value] = token

            for value, token in unique_identifiers.items():
                self.tabTablaSimbolos.insert(
                    tk.END, f"{token.value:<20}{'IDENTIFICADOR':<15}{token.line:<10}{token.column:<10}\n"
                )

            for token in tokens:
                if token.type == TokenType.RESERVED_WORD and token.value not in unique_identifiers:
                    self.tabTablaSimbolos.insert(
                        tk.END, f"{token.value:<20}{'RESERVADA':<15}{token.line:<10}{token.column:<10}\n"
                    )

            self.pestanasAnalisis.select(0)


        # === AN√ÅLISIS SINT√ÅCTICO ===
        if fase == "sintactico" or fase == "all":
            for item in self.tabSintactico.get_children():
                self.tabSintactico.delete(item)


            tokens, _ = self.analizador_lexico.analyze(code)  # Ignora errores l√©xicos aqu√≠
            parser = Parser(tokens)
            ast, sintax_errors = parser.parse()
            # üîç DEBUG: Ver hijos de nodos INCREMENT/DECREMENT
            for nodo in ast.children:
                if nodo.node_type in ["INCREMENT", "DECREMENT"]:
                    print(f"[DEBUG] {nodo.name} tiene {len(nodo.children)} hijo(s)")
                    for hijo in nodo.children:
                        print("     ‚Ü≥", hijo.name)


            #if any("Error l√©xico" in e for e in errors):
             #   messagebox.showwarning("Advertencia", "Existen errores l√©xicos. Se contin√∫a con el an√°lisis sint√°ctico.")

            if sintax_errors:
                pass
            else:
                messagebox.showinfo("Sintaxis", "An√°lisis sint√°ctico exitoso.")

            if ast:
                self.insertar_en_treeview(self.tabSintactico, ast)
                self.mostrar_ast_como_tabla(ast)


            


        # === AN√ÅLISIS SEM√ÅNTICO ===
        if fase == "semantico" or fase == "all":
            self.tabSemantico.delete('1.0', tk.END)
            self.tabSemantico.insert('1.0', "An√°lisis sem√°ntico no implementado todav√≠a.\n")
            if fase == "semantico":
                self.pestanasAnalisis.select(2)

        # === C√ìDIGO INTERMEDIO ===
        if fase == "intermedio" or fase == "all":
            self.tabIntermedio.delete('1.0', tk.END)
            self.tabIntermedio.insert('1.0', "Generaci√≥n de c√≥digo intermedio no implementada todav√≠a.\n")
            if fase == "intermedio":
                self.pestanasAnalisis.select(3)



    def insertar_en_treeview(self, treeview, nodo, parent=""):
        if nodo is None or "ERROR" in getattr(nodo, 'name', ''):
            return

        nombre = getattr(nodo, 'name', 'n/a')
        tipo = getattr(nodo, 'node_type', '')
        linea = getattr(nodo, 'line', 0)
        columna = getattr(nodo, 'column', 0)

    #  Corregimos: quitar "NodeType." para que sea m√°s limpio
        if hasattr(tipo, "name"):
         tipo_texto = tipo.name
        else:
         tipo_texto = str(tipo)

        if "(" in nombre and ")" in nombre:
         nodo_texto = nombre
        elif tipo_texto:
         nodo_texto = f"{tipo_texto} ({nombre})"
        else:
         nodo_texto = nombre

        item_id = treeview.insert(parent, tk.END, text=nodo_texto, values=(tipo_texto, linea, columna))

    # Abrir autom√°ticamente el nodo insertado
        treeview.item(item_id, open=True)

    # Recursivamente insertar hijos
        for hijo in getattr(nodo, 'children', []):
            self.insertar_en_treeview(treeview, hijo, parent=item_id)






    def mostrar_ast_como_tabla(self, nodo):
       def recorrer(nodo, nivel=0, filas=None):
        if filas is None:
            filas = []
        if nodo:
            filas.append({
                "Nombre": nodo.name,
                "Tipo": nodo.node_type.name,
                "L√≠nea": nodo.line,
                "Columna": nodo.column,
                "Nivel": nivel
            })
            for hijo in nodo.children:
                recorrer(hijo, nivel + 1, filas)
        return filas

       filas = recorrer(nodo)
       for fila in filas:
        print(f"{'  ' * fila['Nivel']}- {fila['Nombre']} [{fila['Tipo']}] (L√≠nea {fila['L√≠nea']}, Columna {fila['Columna']})") 


            
    def imprimir_arbol(self, nodo, nivel=0):
        resultado = ""
        if nodo:
            indentacion = "  " * nivel
            resultado += f"{indentacion}- {nodo.name}\n"
            for hijo in nodo.children:
                resultado += self.imprimir_arbol(hijo, nivel + 1)
        return resultado
    
    def generar_tabla_sintactica(self, nodo):
        filas = []

        def recorrer(n):
            if n:
                nombre = getattr(n, 'name', 'n/a')
                tipo = getattr(n, 'type', '')
                linea = getattr(n, 'line', '-')
                columna = getattr(n, 'column', '-')
                filas.append((nombre, tipo, linea, columna))
                for hijo in getattr(n, 'children', []):
                    recorrer(hijo)

        recorrer(nodo)
        return filas


    def ejecutar_codigo(self):
        self.tabSalida.delete('1.0', tk.END)
        self.tabSalida.insert('1.0', "La ejecuci√≥n del c√≥digo no est√° implementada todav√≠a.\n")
        self.pestanasErroresSalida.select(1)
        
    def mostrar_acerca_de(self):
        messagebox.showinfo(
            "Acerca de",
            "Compilador IDE con Analizador L√©xico Integrado\n"
            "Desarrollado para el curso de Compiladores I\n"
            "Mayo 2025"
        )


if __name__ == '__main__':
    root = tk.Tk()
    root.geometry("1200x800")
    app = CompiladorIDE(root)
    root.mainloop()







# sintactico.py

from lexico import TokenType
from arbol_sintaxis import ASTNode, NodeType

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.index = 0
        self.errors = []

    def current_token(self):
        if self.index < len(self.tokens):
            return self.tokens[self.index]
        return None

    def match(self, expected_type, expected_value=None):
        token = self.current_token()
        if token and token.type.name == expected_type:
            if expected_value is None or token.value == expected_value:
                self.index += 1
                return token
        return None

    def consume(self):
        token = self.current_token()
        if token:
            self.index += 1
        return token

    def is_at_end(self):
        return self.index >= len(self.tokens)

    def error(self, message, token=None):
        token = token or self.current_token()
        if token:
            self.errors.append(f"Error sint√°ctico en l√≠nea {token.line}, columna {token.column}: {message}")
        else:
            self.errors.append(f"Error sint√°ctico: {message}")

    def parse(self):
        ast = self.parse_programa()
        return ast, self.errors

    def parse_programa(self):
        token = self.match("RESERVED_WORD", "main")
        if not token:
            self.error("Se esperaba 'main'")
            return None

        main_node = ASTNode("main", NodeType.MAIN, token.line, token.column)

        if not self.match("SYMBOL", "{"):
            self.error("Se esperaba '{'")
            return main_node

        main_node.add_child(self.parse_lista_declaracion())

        if not self.match("SYMBOL", "}"):
            self.error("Se esperaba '}'")
        return main_node

    def parse_lista_declaracion(self):
        node = ASTNode("Lista Declaraciones", NodeType.LISTA)
        while not self.is_at_end() and self.current_token().value != "}":
            decl = self.parse_declaracion()
            if decl:
                node.add_child(decl)
            else:
                self.consume()
        return node

    def parse_declaracion(self):
        token = self.current_token()
        if token and token.type == TokenType.RESERVED_WORD and token.value in ["int", "float", "bool"]:
            return self.parse_declaracion_variable()
        else:
            return self.parse_lista_sentencias()

    def parse_declaracion_variable(self):
        tipo_token = self.consume()
        tipo_node = ASTNode(tipo_token.value, NodeType.TIPO, tipo_token.line, tipo_token.column)
        id_token = self.match("IDENTIFIER")
        if not id_token:
            self.error("Se esperaba identificador")
            return tipo_node
        tipo_node.add_child(ASTNode(id_token.value, NodeType.IDENTIFICADOR, id_token.line, id_token.column))

        while self.match("SYMBOL", ","):
            next_id = self.match("IDENTIFIER")
            if next_id:
                tipo_node.add_child(ASTNode(next_id.value, NodeType.IDENTIFICADOR, next_id.line, next_id.column))
            else:
                self.error("Se esperaba identificador despu√©s de ','")

        if not self.match("SYMBOL", ";"):
            self.error("Se esperaba ';'")
        return tipo_node

    def parse_lista_sentencias(self):
        node = ASTNode("Lista Sentencias", NodeType.LISTA)
        while not self.is_at_end() and self.current_token().value not in ["}", "end"]:
            stmt = self.parse_sentencia()
            if stmt:
                node.add_child(stmt)
            else:
                self.consume()
        return node

    def parse_sentencia(self):
        token = self.current_token()
        if not token:
           return None

        if token.value == "if":
         return self.parse_if()
        elif token.value == "while":
         return self.parse_while()
        elif token.value == "do":
         return self.parse_do()
        elif token.value == "cin":
         return self.parse_entrada()
        elif token.value == "cout":
         return self.parse_salida()
        elif token.type == TokenType.IDENTIFIER:
        # Detectar si es incremento o decremento (ej. a++; o b--; )
         if self.index + 1 < len(self.tokens):
             next_token = self.tokens[self.index + 1]
             if next_token.type in [TokenType.INCREMENT, TokenType.DECREMENT]:
                id_token = self.consume()
                op_token = self.consume()

                # Nodo ra√≠z de la asignaci√≥n
                assign_node = ASTNode("=", NodeType.ASIGNACION, op_token.line, op_token.column)

                # Nodo ID izquierdo
                id_izq = ASTNode(id_token.value, NodeType.IDENTIFICADOR, id_token.line, id_token.column)
                assign_node.add_child(id_izq)

                # Nodo de operaci√≥n: + o -
                op_value = "+" if op_token.type == TokenType.INCREMENT else "-"
                tipo_op = NodeType.SUMA if op_value == "+" else NodeType.RESTA
                op_node = ASTNode(op_value, tipo_op, op_token.line, op_token.column)


                # Operando izquierdo: ID original
                op_node.add_child(ASTNode(id_token.value, NodeType.IDENTIFICADOR, id_token.line, id_token.column))
                # Operando derecho: constante 1
                op_node.add_child(ASTNode("1", NodeType.FACTOR, op_token.line, op_token.column))

                # A√±adir la expresi√≥n al nodo de asignaci√≥n
                assign_node.add_child(op_node)

                self.match("SYMBOL", ";")
                return assign_node

        # Si no es incremento ni decremento, procesar como asignaci√≥n normal
         return self.parse_asignacion()
        else:
            self.error("Sentencia no v√°lida", token)
            return None


        




    def parse_asignacion(self):
        id_token = self.match("IDENTIFIER")
        assign_token = self.match("ASSIGNMENT")
        if not assign_token:
            self.error("Se esperaba '=' en asignaci√≥n")
            return None
        assign_node = ASTNode("Asignaci√≥n", NodeType.ASIGNACION, assign_token.line, assign_token.column)
        assign_node.add_child(ASTNode(id_token.value, NodeType.IDENTIFICADOR, id_token.line, id_token.column))

        if self.current_token().type == TokenType.SYMBOL and self.current_token().value == ";":
            self.match("SYMBOL", ";")  # asignaci√≥n vac√≠a
            return assign_node

        expr = self.parse_expresion()
        if expr:
            assign_node.add_child(expr)

        if not self.match("SYMBOL", ";"):
            self.error("Falta ';' al final de asignaci√≥n")
        return assign_node

    def parse_if(self):
        if_token = self.consume()
        node = ASTNode("if", NodeType.IF, if_token.line, if_token.column)
        node.add_child(self.parse_expresion())

        if not self.match("RESERVED_WORD", "then"):
            self.error("Falta 'then' en if")

        node.add_child(self.parse_lista_sentencias())

        if self.match("RESERVED_WORD", "else"):
            node.add_child(self.parse_lista_sentencias())

        if not self.match("RESERVED_WORD", "end"):
            self.error("Falta 'end' al cerrar if")
        return node

    def parse_while(self):
        while_token = self.consume()
        node = ASTNode("while", NodeType.WHILE, while_token.line, while_token.column)
        node.add_child(self.parse_expresion())
        node.add_child(self.parse_lista_sentencias())
        if not self.match("RESERVED_WORD", "end"):
            self.error("Falta 'end' en while")
        return node

    def parse_do(self):
        do_token = self.consume()
        node = ASTNode("do", NodeType.DO, do_token.line, do_token.column)
        node.add_child(self.parse_lista_sentencias())
        if not self.match("RESERVED_WORD", "while"):
            self.error("Falta 'while' en estructura do")
        node.add_child(self.parse_expresion())
        return node

    def parse_entrada(self):
        cin_token = self.consume()
        node = ASTNode("cin", NodeType.INPUT, cin_token.line, cin_token.column)
        if not self.match("ARITHMETIC_OP", ">>"):
            self.error("Falta '>>' en cin")
            return node
        id_token = self.match("IDENTIFIER")
        if id_token:
            node.add_child(ASTNode(id_token.value, NodeType.IDENTIFICADOR, id_token.line, id_token.column))
        else:
            self.error("Falta identificador en cin")
        self.match("SYMBOL", ";")
        return node

    def parse_salida(self):
        cout_token = self.consume()
        node = ASTNode("cout", NodeType.OUTPUT, cout_token.line, cout_token.column)
        if not self.match("ARITHMETIC_OP", "<<"):
            self.error("Falta '<<' en cout")
            return node
        salida = self.parse_salida_valor()
        if salida:
            node.add_child(salida)
        self.match("SYMBOL", ";")
        return node

    def parse_salida_valor(self):
        token = self.current_token()
        if token.type == TokenType.STRING:
            self.consume()
            return ASTNode(token.value, NodeType.CADENA, token.line, token.column)
        else:
            return self.parse_expresion()

    def parse_expresion(self):
        left = self.parse_expresion_simple()
        token = self.current_token()
        if token and token.type == TokenType.RELATIONAL_OP:
            op_token = self.consume()
            op_node = ASTNode(op_token.value, NodeType.RELACIONAL, op_token.line, op_token.column)
            op_node.add_child(left)
            right = self.parse_expresion_simple()
            if right:
                op_node.add_child(right)
            return op_node
        return left

    def parse_expresion_simple(self):
        node = self.parse_termino()
        while not self.is_at_end():
            token = self.current_token()
            if token.type == TokenType.ARITHMETIC_OP and token.value in ["+", "-"]:
                op_token = self.consume()
                tipo = NodeType.SUMA if op_token.value == "+" else NodeType.RESTA
                op_node = ASTNode(op_token.value, tipo, op_token.line, op_token.column)
                op_node.add_child(node)
                op_node.add_child(self.parse_termino())
                node = op_node
            elif token.type in [TokenType.INCREMENT, TokenType.DECREMENT]:
                op_token = self.consume()
                tipo = NodeType.INCREMENTO if op_token.type == TokenType.INCREMENT else NodeType.DECREMENTO
                op_node = ASTNode(op_token.value, tipo, op_token.line, op_token.column)
                op_node.add_child(node)
                node = op_node
            else:
                break
        return node
    


    def parse_termino(self):
        node = self.parse_factor()
        while not self.is_at_end():
            token = self.current_token()
            if token.type == TokenType.ARITHMETIC_OP and token.value in ["*", "/", "%"]:
                op_token = self.consume()
                op_node = ASTNode(op_token.value, NodeType.MULTIPLICACION, op_token.line, op_token.column)
                op_node.add_child(node)
                op_node.add_child(self.parse_factor())
                node = op_node
            else:
                break
        return node

    def parse_factor(self):
        node = self.parse_componente()
        while not self.is_at_end():
            token = self.current_token()
            if token.type == TokenType.ARITHMETIC_OP and token.value == "^":
                op_token = self.consume()
                op_node = ASTNode("^", NodeType.POTENCIA, op_token.line, op_token.column)
                op_node.add_child(node)
                op_node.add_child(self.parse_componente())
                node = op_node
            else:
                break
        return node

    def parse_componente(self):
        token = self.current_token()
        if token is None:
            return None

        if token.type == TokenType.SYMBOL and token.value == "(":
            self.consume()
            expr = self.parse_expresion()
            self.match("SYMBOL", ")")
            return expr
        elif token.type == TokenType.INTEGER or token.type == TokenType.DECIMAL:
            self.consume()
            return ASTNode(token.value, NodeType.FACTOR, token.line, token.column)
        elif token.type == TokenType.IDENTIFIER:
            self.consume()
            return ASTNode(token.value, NodeType.IDENTIFICADOR, token.line, token.column)
        elif token.type == TokenType.RESERVED_WORD and token.value in ["true", "false"]:
            self.consume()
            return ASTNode(token.value, NodeType.FACTOR, token.line, token.column)
        elif token.type == TokenType.LOGICAL_OP or token.value == "!":
            op = self.consume()
            op_node = ASTNode(op.value, NodeType.LOGICO, op.line, op.column)
            op_node.add_child(self.parse_componente())
            return op_node
        else:
            self.error("Componente inv√°lido", token)
            self.consume()
            return None






# arbol_sintaxis.py

from enum import Enum

class NodeType(Enum):
    PROGRAMA = "Programa"
    DECLARACION = "Declaraci√≥n"
    TIPO = "Tipo"
    IDENTIFICADOR = "Identificador"
    SENTENCIA = "Sentencia"
    ASIGNACION = "Asignaci√≥n"
    EXPRESION = "Expresi√≥n"
    EXPRESION_SIMPLE = "Expresi√≥n Simple"
    TERMINO = "T√©rmino"
    FACTOR = "Factor"
    COMPONENTE = "Componente"
    OPERADOR = "Operador"
    IF = "If"
    WHILE = "While"
    DO = "Do"
    INPUT = "Entrada"
    OUTPUT = "Salida"
    RELACIONAL = "Relacional"
    SUMA = "Suma"
    RESTA = "Resta"
    MULTIPLICACION = "Multiplicaci√≥n"
    POTENCIA = "Potencia"
    LOGICO = "L√≥gico"
    INCREMENTO = "Incremento"
    DECREMENTO = "Decremento"
    CADENA = "Cadena"
    LISTA = "Lista"
    MAIN = "Main"
    ERROR = "Error"

class ASTNode:
    def __init__(self, name, node_type, line=None, column=None):
        self.name = name                  # Texto del nodo (ej. '+', 'if', 'id', 'int')
        self.node_type = node_type        # Tipo de nodo (NodeType)
        self.line = line                  # L√≠nea en el c√≥digo fuente
        self.column = column              # Columna en el c√≥digo fuente
        self.children = []                # Lista de hijos (nodos AST)

    def add_child(self, child_node):
        if child_node:
            self.children.append(child_node)

    def __repr__(self):
        return f"{self.node_type.name}('{self.name}') [{self.line}:{self.column}]"

    def to_dict(self):
        """Convierte el nodo a un diccionario para visualizaci√≥n"""
        return {
            "name": self.name,
            "type": self.node_type.name,
            "line": self.line,
            "column": self.column,
            "children": [child.to_dict() for child in self.children]
        }